//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//
//       bebopc version:
//           3.2.1
//
//
//       bebopc source:
//           https://github.com/6over3/bebop
//
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
import { BebopView, BebopRuntimeError, type BebopRecord } from "bebop";

export const BEBOP_SCHEMA = new Uint8Array ([
3, 2, 0, 0, 0, 67, 104, 97, 105, 110, 0, 1, 0, 0, 10, 0,
0, 0, 0, 2, 111, 114, 100, 101, 114, 0, 253, 255, 255,
255, 0, 109, 111, 100, 101, 108, 0, 1, 0, 0, 0, 0, 77,
111, 100, 101, 108, 0, 1, 0, 0, 8, 0, 0, 0, 0, 2, 115,
116, 97, 116, 101, 115, 0, 241, 255, 255, 255, 246, 255,
255, 255, 241, 255, 255, 255, 246, 255, 255, 255, 251,
255, 255, 255, 0, 100, 105, 99, 116, 105, 111, 110, 97,
114, 121, 0, 241, 255, 255, 255, 245, 255, 255, 255, 246,
255, 255, 255, 0, 0, 0, 0, 0
]);

export interface Chain {

  readonly order: number;

  readonly model: Model;
}

export const Chain = /*#__PURE__*/ Object.freeze(/*#__PURE__*/ Object.assign(
  // Factory function
  (data: Chain): Chain & BebopRecord => {
    return Object.freeze({
      ...data,
      encode(): Uint8Array {
        return Chain.encode(this);
      }
    });
  },
  // Static methods
  {
    encode(record: Chain): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      Chain.encodeInto(record, view);
      return view.toArray();
    },

    encodeInto(record: Chain, view: BebopView): void {
      view.writeUint16(record.order);
      Model.encodeInto(record.model, view);
    },

    decode(buffer: Uint8Array): Chain & BebopRecord {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      const decoded = Chain.readFrom(view);
      return Chain(decoded);
    },

    readFrom(view: BebopView): Chain {
      let field0: number;
      field0 = view.readUint16();
      let field1: Model;
      field1 = Model.readFrom(view);
      return {
        order: field0,
        model: field1,
      };
    },
  }
));


export interface Model {

  readonly states: Map<number, Map<number, number>>;

  readonly dictionary: Map<string, number>;
}

export const Model = /*#__PURE__*/ Object.freeze(/*#__PURE__*/ Object.assign(
  // Factory function
  (data: Model): Model & BebopRecord => {
    return Object.freeze({
      ...data,
      encode(): Uint8Array {
        return Model.encode(this);
      }
    });
  },
  // Static methods
  {
    encode(record: Model): Uint8Array {
      const view = BebopView.getInstance();
      view.startWriting();
      Model.encodeInto(record, view);
      return view.toArray();
    },

    encodeInto(record: Model, view: BebopView): void {
      view.writeUint32(record.states.size);
      for (const [k0, v0] of record.states) {
        view.writeFloat64(k0);
        view.writeUint32(v0.size);
        for (const [k1, v1] of v0) {
          view.writeFloat64(k1);
          view.writeUint32(v1);
        }
      }
      view.writeUint32(record.dictionary.size);
      for (const [k0, v0] of record.dictionary) {
        view.writeString(k0);
        view.writeFloat64(v0);
      }
    },

    decode(buffer: Uint8Array): Model & BebopRecord {
      const view = BebopView.getInstance();
      view.startReading(buffer);
      const decoded = Model.readFrom(view);
      return Model(decoded);
    },

    readFrom(view: BebopView): Model {
      let field0: Map<number, Map<number, number>>;
      {
        const length0 = view.readUint32();
        field0 = new Map();
        for (let i0 = 0; i0 < length0; i0++) {
          let k0: number;
          let v0: Map<number, number>;
          k0 = view.readFloat64();
          {
            const length1 = view.readUint32();
            v0 = new Map();
            for (let i1 = 0; i1 < length1; i1++) {
              let k1: number;
              let v1: number;
              k1 = view.readFloat64();
              v1 = view.readUint32();
              v0.set(k1, v1);
            }
          }
          field0.set(k0, v0);
        }
      }
      let field1: Map<string, number>;
      {
        const length0 = view.readUint32();
        field1 = new Map();
        for (let i0 = 0; i0 < length0; i0++) {
          let k0: string;
          let v0: number;
          k0 = view.readString();
          v0 = view.readFloat64();
          field1.set(k0, v0);
        }
      }
      return {
        states: field0,
        dictionary: field1,
      };
    },
  }
));

